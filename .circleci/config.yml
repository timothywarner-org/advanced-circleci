# ============================================================================
# MODULE 3: Production Orbs Integration with Slack Notifications
# ============================================================================
# Real-world pipeline for the Globomantics Robot Fleet API:
#   - circleci/node: Battle-tested Node.js workflows
#   - circleci/slack: Rich notifications to #circleci-builds
#   - Approval gates before production
#   - Simulated Azure deployments (no actual cloud resources)
#
# TEACHING POINTS:
#   - Orb version pinning strategy (exact versions for stability)
#   - Context-based secrets management (slack-notifications)
#   - Notification strategy (fail fast on tests, confirm deployments)
#   - Approval workflow pattern for production safety
# ============================================================================

version: 2.1

# ============================================================================
# ORBS: Certified packages from CircleCI ecosystem
# ============================================================================
orbs:
  node: circleci/node@7.2.1         # Node.js convenience commands with caching
  slack: circleci/slack@6.1.2       # Slack notifications with rich templates

# ============================================================================
# EXECUTORS: Reusable execution environments
# ============================================================================
executors:
  node-executor:
    docker:
      - image: cimg/node:22.16.0    # Official CircleCI Node 22 LTS image
    working_directory: ~/robot-fleet-api
    resource_class: medium          # 2 vCPU, 4GB RAM

# ============================================================================
# COMMANDS: Reusable step sequences
# ============================================================================
commands:
  # Simulate Azure deployment without actual cloud resources
  simulate-azure-deployment:
    parameters:
      environment:
        type: enum
        enum: [dev, staging, prod]
        description: "Target environment"
      app-name:
        type: string
        description: "Azure Container App name"
    steps:
      - run:
          name: Simulate Azure Container Build
          command: |
            echo "════════════════════════════════════════════════════════"
            echo "  SIMULATED: Building container image"
            echo "════════════════════════════════════════════════════════"
            echo "Image: robot-fleet-api:${CIRCLE_SHA1:0:7}"
            echo "Environment: << parameters.environment >>"
            echo "Build completed successfully ✓"
            sleep 2  # Simulate build time

      - run:
          name: Simulate Azure Container App Deployment
          command: |
            echo "════════════════════════════════════════════════════════"
            echo "  SIMULATED: Deploying to Azure Container Apps"
            echo "════════════════════════════════════════════════════════"
            echo "App Name: << parameters.app-name >>"
            echo "Resource Group: rg-globomantics-<< parameters.environment >>"
            echo "Image: robot-fleet-api:${CIRCLE_SHA1:0:7}"
            echo ""
            echo "Deployment steps:"
            echo "  1. Authenticating to Azure... ✓"
            echo "  2. Pushing image to ACR... ✓"
            echo "  3. Updating container app... ✓"
            echo "  4. Verifying health check... ✓"
            echo ""
            echo "Deployment URL: https://<< parameters.app-name >>.azurecontainerapps.io"
            echo "Status: RUNNING"
            echo ""
            echo "Deployment completed successfully ✓"

      - run:
          name: Simulate Health Check
          command: |
            echo "════════════════════════════════════════════════════════"
            echo "  SIMULATED: Health Check"
            echo "════════════════════════════════════════════════════════"
            echo "Endpoint: https://<< parameters.app-name >>.azurecontainerapps.io/api/health"
            echo ""
            for i in {1..3}; do
              echo "Attempt $i/3... ✓ HTTP 200 OK"
              sleep 1
            done
            echo ""
            echo "Health check passed ✓"

# ============================================================================
# JOBS: Complete units of work
# ============================================================================
jobs:
  # Build the application and cache dependencies
  build:
    executor: node-executor
    steps:
      - checkout

      # Orb command handles: restore_cache, npm ci, save_cache automatically
      - node/install-packages:
          pkg-manager: npm
          cache-version: v1

      - run:
          name: Build Application
          command: |
            echo "Building Robot Fleet API..."
            npm run build
            echo "Build completed successfully ✓"

      # Persist artifacts for downstream jobs
      - persist_to_workspace:
          root: .
          paths:
            - node_modules
            - dist
            - package*.json

  # Run test suite with Slack notification on failure
  test:
    executor: node-executor
    steps:
      - checkout
      - attach_workspace:
          at: .

      - run:
          name: Run Unit Tests
          command: |
            echo "Running Robot Fleet API test suite..."
            npm test
            echo "Tests completed successfully ✓"

      - store_test_results:
          path: test-results

      - store_artifacts:
          path: coverage
          destination: coverage-report

      # CRITICAL: Notify on test failure (fail fast pattern)
      # Only notifies if previous steps failed
      - slack/notify:
          event: fail
          template: basic_fail_1
          channel: C0A6655DKS6  # #circleci-builds channel ID

  # Simulate deployment to Azure environment
  deploy:
    executor: node-executor
    parameters:
      environment:
        type: enum
        enum: [dev, staging, prod]
        description: "Deployment environment"
      app-name:
        type: string
        description: "Azure Container App name"
    steps:
      - checkout
      - attach_workspace:
          at: .

      # Simulate Azure deployment (no actual cloud resources)
      - simulate-azure-deployment:
          environment: << parameters.environment >>
          app-name: << parameters.app-name >>

      # Notify on successful deployment using built-in template
      - slack/notify:
          event: pass
          template: basic_success_1
          channel: C0A6655DKS6  # #circleci-builds channel ID

# ============================================================================
# WORKFLOWS: Orchestrate job execution with approval gates
# ============================================================================
workflows:
  version: 2

  # Primary workflow: Build → Test → Dev → Staging → Approve → Prod
  build-test-deploy:
    jobs:
      # Build on all branches
      - build:
          filters:
            branches:
              only:
                - main
                - develop
                - /feature\/.*/

      # Test after successful build
      # Context provides SLACK_ACCESS_TOKEN env var (required by slack orb)
      - test:
          requires:
            - build
          context: slack-notifications

      # ──────────────────────────────────────────────────────────────
      # DEV ENVIRONMENT: Auto-deploy after tests pass
      # ──────────────────────────────────────────────────────────────
      - deploy:
          name: deploy-dev
          environment: dev
          app-name: robot-api-dev
          requires:
            - test
          context: slack-notifications
          filters:
            branches:
              only:
                - develop
                - /feature\/.*/

      # ──────────────────────────────────────────────────────────────
      # STAGING ENVIRONMENT: Auto-deploy from main branch only
      # ──────────────────────────────────────────────────────────────
      - deploy:
          name: deploy-staging
          environment: staging
          app-name: robot-api-staging
          requires:
            - test
          context: slack-notifications
          filters:
            branches:
              only: main

      # ──────────────────────────────────────────────────────────────
      # APPROVAL GATE: Manual intervention required for production
      # ──────────────────────────────────────────────────────────────

      # Slack notification: "Staging deployed, ready for prod approval"
      - slack/on-hold:
          context: slack-notifications
          channel: C0A6655DKS6  # #circleci-builds channel ID
          requires:
            - deploy-staging
          filters:
            branches:
              only: main

      # Pause workflow for human approval
      - hold-for-production:
          type: approval
          requires:
            - deploy-staging
            - slack/on-hold
          filters:
            branches:
              only: main

      # ──────────────────────────────────────────────────────────────
      # PRODUCTION ENVIRONMENT: Only after manual approval
      # ──────────────────────────────────────────────────────────────
      - deploy:
          name: deploy-prod
          environment: prod
          app-name: robot-api-prod
          requires:
            - hold-for-production
          context: slack-notifications
          filters:
            branches:
              only: main

# ============================================================================
# DEMO SCENARIOS
# ============================================================================
#
# Scenario 1: Feature Branch
# ──────────────────────────────────────────────────────────────────────────
# Branch: feature/new-robot-endpoint
# Flow: build → test → deploy-dev
# Notifications: Test failure (if tests fail)
#                Deployment success (dev environment)
#
# Scenario 2: Main Branch (Full Pipeline)
# ──────────────────────────────────────────────────────────────────────────
# Branch: main
# Flow: build → test → deploy-staging → [approval gate] → deploy-prod
# Notifications: Test failure (if tests fail)
#                Staging deployment success
#                Production approval needed
#                Production deployment success
#
# Scenario 3: Test Failure
# ──────────────────────────────────────────────────────────────────────────
# Branch: any
# Flow: build → test [FAILS]
# Notifications: Slack alert to #circleci-builds with failure details
# Result: Pipeline stops, no deployments occur
#
# ============================================================================
# TEACHING POINTS DEMONSTRATED
# ============================================================================
#
# 1. ORB VERSION PINNING:
#    node@7.2.1    - Exact patch version for maximum reproducibility
#    slack@6.1.2   - Exact version (maximum stability)
#
#    Why not @7 or @6? Because major version pins get breaking changes.
#    Why not @volatile? Because it's literally called "volatile" - never use it.
#
# 2. CONTEXT-BASED SECRETS:
#    context: slack-notifications
#    - Stores SLACK_ACCESS_TOKEN securely (required by slack orb)
#    - Scoped to organization
#    - No secrets in config file
#    - Least privilege access
#
# 3. NOTIFICATION STRATEGY:
#    Tests: Notify on FAILURE only (fail fast)
#    Deployments: Notify on SUCCESS (confirmation)
#    Why? Tests fail frequently during dev, but deployments are milestones.
#
# 4. APPROVAL GATES:
#    type: approval pauses the workflow
#    Human clicks "Approve" in CircleCI UI
#    Audit trail: who approved, when, from which IP
#    Compliance requirement for production changes
#
# 5. WORKSPACE PERSISTENCE:
#    persist_to_workspace: Saves build artifacts
#    attach_workspace: Loads artifacts in downstream jobs
#    Why? Avoids rebuilding in every job (faster, more reliable)
#
# 6. BRANCH FILTERING:
#    Feature branches → dev only
#    Main branch → staging + prod (after approval)
#    Prevents accidental production deployments from feature branches
#
# ============================================================================
