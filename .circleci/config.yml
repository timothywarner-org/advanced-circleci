# ============================================================================
# MODULE 1: Workflow Orchestration Best Practices
# ============================================================================
# Fan-out/Fan-in pattern: Build once, test in parallel, converge to deploy.
# Uses workspace to share node_modules across jobs (install once, use many).
#
# WORKFLOW VISUALIZATION:
#
#   require-approval=true (default):
#                    ┌─► lint ──────────┐
#                    │                  │
#   build ──────────►├─► test-unit ─────┼──► [approve-deploy] ──► deploy-simulation
#                    │                  │
#                    ├─► test-integ ────┤
#                    │                  │
#                    └─► test-e2e ──────┘
#
#   require-approval=false (auto-deploy):
#                    ┌─► lint ──────────┐
#                    │                  │
#   build ──────────►├─► test-unit ─────┼──────► deploy-simulation
#                    │                  │
#                    ├─► test-integ ────┤
#                    │                  │
#                    └─► test-e2e ──────┘
#
#   Total time: ~2-3 min (parallel) vs ~6-8 min (sequential)
# ============================================================================

version: 2.1

# ============================================================================
# PIPELINE PARAMETERS: Configurable via API, UI, or triggers
# ============================================================================
parameters:
  require-approval:
    type: boolean
    default: true
    description: "Require manual approval before deploy (false = auto-deploy)"

  hello-message:
    type: enum
    default: hello-world
    enum:
      - hello-world
      - hola-mundo
      - hi-there
    description: "Greeting echoed during deploy (no default; pass at trigger time)"

  demo-message:
    type: string
    default: "I was set at PIPELINE TRIGGER time (before compute)"
    description: "Demo parameter to show params vs env vars"

jobs:
  # --------------------------------------------------------------------------
  # TEACHING DEMO: Parameters vs Environment Variables
  # --------------------------------------------------------------------------
  params-vs-envvars:
    docker:
      - image: cimg/base:current
    # ENVIRONMENT KEY: Set at job level in config.yml, but resolved at RUNTIME
    environment:
      STATIC_ENV: "I was set in config.yml, but resolved at RUNTIME"
    steps:
      - run:
          name: "DEMO: Pipeline Parameters vs Environment Variables"
          command: |
            echo "============================================================"
            echo "  PIPELINE PARAMETER (resolved BEFORE compute spins up)"
            echo "============================================================"
            echo "  Value: << pipeline.parameters.demo-message >>"
            echo "  Syntax: << pipeline.parameters.demo-message >>"
            echo "  Note: This text was substituted during config compilation!"
            echo ""
            echo "============================================================"
            echo "  STATIC ENV VAR (set in config.yml, resolved at RUNTIME)"
            echo "============================================================"
            echo "  Value: $STATIC_ENV"
            echo "  Syntax: \$STATIC_ENV"
            echo "  Set via 'environment:' key at job level in config.yml"
            echo ""
            echo "============================================================"
            echo "  BUILT-IN CIRCLECI ENV VARS (always available at runtime)"
            echo "============================================================"
            echo "  CIRCLE_BRANCH:    $CIRCLE_BRANCH"
            echo "  CIRCLE_SHA1:      ${CIRCLE_SHA1:0:7} (truncated)"
            echo "  CIRCLE_BUILD_NUM: $CIRCLE_BUILD_NUM"
            echo "  CIRCLE_JOB:       $CIRCLE_JOB"
            echo "  CIRCLE_WORKFLOW_ID: ${CIRCLE_WORKFLOW_ID:0:8}..."
            echo ""
            echo "============================================================"
            echo "  DYNAMIC ENV VAR (created during job execution)"
            echo "============================================================"
            DYNAMIC_VAR="I was created at $(date '+%Y-%m-%d %H:%M:%S')"
            echo "  Value: $DYNAMIC_VAR"
            echo "  Note: Created with 'export' or assignment in shell"
            echo ""
            echo "============================================================"
            echo "  KEY DIFFERENCES SUMMARY"
            echo "============================================================"
            echo "  | Aspect              | Parameters      | Env Vars       |"
            echo "  |---------------------|-----------------|----------------|"
            echo "  | Resolved            | Before compute  | At runtime     |"
            echo "  | Can skip jobs       | YES             | NO             |"
            echo "  | Can be dynamic      | NO              | YES            |"
            echo "  | Set mid-job         | NO              | YES            |"
            echo "============================================================"


  # --------------------------------------------------------------------------
  # TEACHING DEMO: Contexts and Secrets
  # --------------------------------------------------------------------------
  # CONTEXTS: Org-level secret stores shared across projects
  # - Created in CircleCI UI: Organization Settings → Contexts
  # - Secrets injected as environment variables at RUNTIME
  # - Values are MASKED in logs (CircleCI replaces them with ****)
  # - Context must be explicitly attached to job in workflow (see below)
  # --------------------------------------------------------------------------
  secrets-demo:
    docker:
      - image: cimg/base:current
    steps:
      - run:
          name: "DEMO: Using Secrets from CircleCI Contexts"
          command: |
            echo "============================================================"
            echo "  CIRCLECI CONTEXTS: Secure Secret Management"
            echo "============================================================"
            echo ""
            echo "  Context Name: azure-production-credentials"
            echo "  Secret Name:  VM_PASSWORD"
            echo ""
            echo "============================================================"
            echo "  SECURITY: Secrets are automatically masked in logs"
            echo "============================================================"
            echo "  If I try to echo the secret directly..."
            echo "  VM_PASSWORD value: $VM_PASSWORD"
            echo "  ↑ CircleCI replaced the actual value with **** above!"
            echo ""
            echo "============================================================"
            echo "  CHECKING SECRET AVAILABILITY"
            echo "============================================================"
            if [ -n "$VM_PASSWORD" ]; then
              echo "  ✓ VM_PASSWORD is set (${#VM_PASSWORD} characters)"
              echo "  ✓ Secret successfully injected from context!"
            else
              echo "  ✗ VM_PASSWORD is NOT set"
              echo "  → Did you attach the context in the workflow?"
              echo "  → Does the context 'azure-production-credentials' exist?"
            fi
            echo ""
            echo "============================================================"
            echo "  CONTEXT BEST PRACTICES"
            echo "============================================================"
            echo "  1. Use contexts for secrets, NOT project env vars"
            echo "  2. Create separate contexts per environment (dev/prod)"
            echo "  3. Restrict context access with security groups"
            echo "  4. Rotate secrets regularly via CircleCI UI"
            echo "  5. Never echo secrets - they'll be masked, but still risky"
            echo ""
            echo "============================================================"
            echo "  HOW TO USE IN YOUR CONFIG"
            echo "============================================================"
            echo "  In workflow, attach context to job:"
            echo ""
            echo "    workflows:"
            echo "      my-workflow:"
            echo "        jobs:"
            echo "          - my-job:"
            echo "              context: azure-production-credentials"
            echo ""
            echo "  Then access in job as \$VM_PASSWORD"
            echo "============================================================"

  # --------------------------------------------------------------------------
  # BUILD: Install deps once, persist to workspace for all downstream jobs
  # --------------------------------------------------------------------------
  build:
    docker:
      - image: cimg/node:20.18
    steps:
      - checkout
      # CACHING: Restores node_modules from cache if package-lock.json unchanged
      # First key = exact match, second key = partial fallback (may need npm ci)
      - restore_cache:
          keys:
            - deps-v1-{{ checksum "package-lock.json" }}
            - deps-v1-
      - run:
          name: Install dependencies
          command: npm ci
      # Save to cache after install; only runs if key doesn't already exist
      - save_cache:
          key: deps-v1-{{ checksum "package-lock.json" }}
          paths:
            - node_modules
      - run:
          name: Build application
          command: npm run build
      # KEY CONCEPT: Persist workspace so downstream jobs skip npm ci
      - persist_to_workspace:
          root: .
          paths:
            - node_modules
            - dist

  # --------------------------------------------------------------------------
  # PARALLEL JOBS: All attach workspace, run simultaneously after build
  # --------------------------------------------------------------------------
  lint:
    docker:
      - image: cimg/node:20.18
    steps:
      - checkout
      - attach_workspace:
          at: .
      - run:
          name: Run linter
          command: npm run lint

  test-unit:
    docker:
      - image: cimg/node:20.18
    steps:
      - checkout
      - attach_workspace:
          at: .
      - run:
          name: Run unit tests
          command: npm run test:unit
      # store_test_results: Uploads JUnit XML for CircleCI's Test Insights tab
      # Enables test timing analysis, flaky test detection, and historical trends
      - store_test_results:
          path: test-results
      - store_artifacts:
          path: coverage
          destination: unit-coverage

  test-integration:
    docker:
      - image: cimg/node:20.18
    steps:
      - checkout
      - attach_workspace:
          at: .
      - run:
          name: Run integration tests
          command: npm run test:integration
      # Parses test XML for the Insights dashboard (separate from artifacts)
      - store_test_results:
          path: test-results

  test-e2e:
    docker:
      - image: cimg/node:20.18
    steps:
      - checkout
      - attach_workspace:
          at: .
      - run:
          name: Run E2E tests
          command: npm run test:e2e
      # Test results enable automatic test splitting in future parallelism configs
      - store_test_results:
          path: test-results

  # --------------------------------------------------------------------------
  # DEPLOY SIMULATION: Fan-in - requires ALL parallel jobs to pass
  # --------------------------------------------------------------------------
  deploy-simulation:
    docker:
      - image: cimg/node:20.18
    steps:
      - checkout
      - attach_workspace:
          at: .
      - run:
          name: Deploy Robot Fleet API (simulated)
          command: |
            echo "==========================================="
            echo "  DEPLOYING GLOBOMANTICS ROBOT FLEET API"
            echo "==========================================="
            # CIRCLE_BRANCH: Git branch that triggered this pipeline
            echo "  Branch: ${CIRCLE_BRANCH}"
            # CIRCLE_SHA1: Full 40-char Git commit SHA (truncated here to 7)
            echo "  Commit: ${CIRCLE_SHA1:0:7}"
            # CIRCLE_BUILD_NUM: Auto-incrementing build number for this project
            echo "  Build:  ${CIRCLE_BUILD_NUM}"
            echo "==========================================="

      # -----------------------------------------------------------------------
      # CONDITIONAL STEPS: when + equal pattern (like if/else if/else if)
      # Each 'when' block only executes if its condition matches the enum value
      # -----------------------------------------------------------------------
      - when:
          condition:
            equal: [hello-world, << pipeline.parameters.hello-message >>]
          steps:
            - run:
                name: Greeting (English)
                command: echo "Hello, World! Welcome to Globomantics Robot Fleet!"

      - when:
          condition:
            equal: [hola-mundo, << pipeline.parameters.hello-message >>]
          steps:
            - run:
                name: Greeting (Spanish)
                command: echo "¡Hola, Mundo! ¡Bienvenido a la Flota de Robots Globomantics!"

      - when:
          condition:
            equal: [hi-there, << pipeline.parameters.hello-message >>]
          steps:
            - run:
                name: Greeting (Casual)
                command: echo "Hi there! Ready to deploy some robots?"

      - run:
          name: Deployment complete
          command: echo "Deployment successful! (simulated)"

# ============================================================================
# WORKFLOW: Fan-out after build, fan-in before deploy
# ============================================================================
# Two workflows controlled by pipeline parameter - only one runs at a time
workflows:
  # --------------------------------------------------------------------------
  # WORKFLOW 1: With approval gate (default when require-approval=true)
  # --------------------------------------------------------------------------
  m1-build-test-deploy:
    # WHEN at workflow level: entire workflow only runs if condition is true
    when: << pipeline.parameters.require-approval >>
    jobs:
      - build:
          filters:
            branches:
              only:
                - main
                - /feature\/.*/

      # FAN-OUT: These 4 jobs all require build, so they run in PARALLEL
      - lint:
          requires:
            - build

      - test-unit:
          requires:
            - build

      - test-integration:
          requires:
            - build

      - test-e2e:
          requires:
            - build

      # APPROVAL GATE: Pauses workflow until someone clicks "Approve" in UI
      # type: approval = special job with no compute cost while waiting
      - approve-deploy:
          type: approval
          requires:
            - lint
            - test-unit
            - test-integration
            - test-e2e
          filters:
            branches:
              only: main

      # FAN-IN: Deploy only after manual approval
      - deploy-simulation:
          requires:
            - approve-deploy
          filters:
            branches:
              only: main

  # --------------------------------------------------------------------------
  # WORKFLOW 2: Auto-deploy without approval (when require-approval=false)
  # --------------------------------------------------------------------------
  m1-build-test-deploy-auto:
    # UNLESS at workflow level: runs when condition is false (inverse of when)
    unless: << pipeline.parameters.require-approval >>
    jobs:
      # Standalone demo jobs - no dependencies, run immediately in parallel
      - params-vs-envvars

      # CONTEXT ATTACHMENT: The 'context' key injects secrets from that context
      # Without this line, $VM_PASSWORD would be empty in the job!
      - secrets-demo:
          context: azure-production-credentials

      - build:
          filters:
            branches:
              only:
                - main
                - /feature\/.*/

      - lint:
          requires:
            - build

      - test-unit:
          requires:
            - build

      - test-integration:
          requires:
            - build

      - test-e2e:
          requires:
            - build

      # FAN-IN: Deploy directly after tests pass (no approval gate)
      - deploy-simulation:
          requires:
            - lint
            - test-unit
            - test-integration
            - test-e2e
          filters:
            branches:
              only: main

# ============================================================================
# MODULE 1 KEY CONCEPTS DEMONSTRATED:
#
# 1. REQUIRES KEYWORD: Creates job dependencies (build → tests → deploy)
# 2. FAN-OUT: Multiple jobs with same requirement run in parallel
# 3. FAN-IN: Single job requiring multiple predecessors waits for all
# 4. BRANCH FILTERS: Control which branches trigger which jobs
# 5. WORKSPACE: Share artifacts between jobs (eliminates redundant npm ci)
# 6. APPROVAL GATES: type: approval pauses workflow for manual approval
# 7. PIPELINE PARAMETERS: Feature flags to control workflow behavior
# 8. CONDITIONAL WORKFLOWS: when/unless at WORKFLOW level toggles entire flows
#    (Note: when/unless must be at workflow level, not individual job level)
# 9. CONDITIONAL STEPS: when + equal at STEP level for if/else if branching
#    - Use 'when:' with 'condition: equal: [value, << param >>]' syntax
#    - Each matching 'when' block executes its steps (not mutually exclusive)
#    - Great for enum parameters with different behavior per value
# 10. CONTEXTS: Org-level secret stores (Organization Settings → Contexts)
#    - Attach to job with 'context: context-name' in workflow
#    - Secrets injected as env vars at runtime ($SECRET_NAME)
#    - Values automatically masked (*****) in job logs
#    - Use for credentials, API keys, passwords - never project env vars
#
# TRIGGERING WITH PARAMETERS (via API or curl):
#   curl -X POST https://circleci.com/api/v2/project/gh/OWNER/REPO/pipeline \
#     -H "Circle-Token: $TOKEN" -H "Content-Type: application/json" \
#     -d '{"parameters": {"require-approval": false, "hello-message": "hola-mundo"}}'
#
# CREDIT CONSUMPTION: Same as sequential! You pay for compute time, not wall time.
# ============================================================================
