**Video Course Outline**

| **Approved Date** | YYYY-MM-DD |
| --- | --- |

| Course Information  This section is completed by Curriculum | |
| --- | --- |
| Course Title | CircleCI Advanced Configuration |
| Author Name | *Tim Warner* |
| Opportunity ID | *08b176c1-6326-49cf-949f-49497068f09a* |
| Course Slug | *circleci-advanced-config* |
| Skill Path | CircleCI |
| Path Placement | 2 |
| Job Role | *System Administrator, Systems Engineer, DevOps Engineer, Cloud Engineer* |
| Content Level  *(Beginner, Intermediate, Advanced)* | *Intermediate* |
| **Content Tags** | *IT Ops, DevOps, Continuous integration, Continuous delivery, Configuration and deployment, CircleCI* |
| Length in minutes | 90 |
| Curriculum Notes Versions and platform-specific notes may be provided here. | *Style: Video Course | Standard Course   Learner Profile: The learner profile for this course is The Orchestrator. This engineer must manage simultaneous builds, enforce testing dependencies (e.g., ensuring a service starts before integration tests run), and create maintainable, standardized pipeline components across multiple repositories.  Additional Notes: This comprehensive learning path provides the fundamental knowledge and advanced techniques required to design, implement, and optimize robust Continuous Integration and Continuous Delivery (CI/CD) pipelines using CircleCI. Learners will progress from basic project setup to mastering complex workflows, security contexts, and high-efficiency build strategies essential for modern DevOps success.* |

| Course Planning  This section is completed by Author | |
| --- | --- |
| Learner Profile Who will be taking this course? | *Intermediate IT professionals and DevOps engineers who have completed "Getting Started with CircleCI" and are now responsible for scaling CI/CD practices across teams. They manage multiple repositories, need to reduce configuration duplication, and must implement sophisticated workflow patterns to handle complex build dependencies and deployment sequences.* |
| Learner Prerequisites What do they already know? | *Completion of "Getting Started with CircleCI" or equivalent hands-on experience with CircleCI pipelines.*  *Working knowledge of .circleci/config.yml structure including version 2.1, jobs, steps, executors, and basic workflows.*  *Familiarity with Git version control and GitHub Enterprise Cloud or similar VCS platforms.*  *Experience with at least one programming language (Node.js used for examples, but concepts are transferable).*  *Understanding of basic CI/CD concepts: automated builds, testing, and deployment.* |
| Purpose What real-world problem will you solve in your course? | *As development teams scale, CI/CD configurations become unwieldy. The fictional Globomantics robotics company has grown from one Node.js application to a fleet of microservices, and their config.yml files are bloated with duplicated YAML across repositories. Build times are unpredictable because workflow dependencies aren't properly orchestrated—sometimes deployments run before tests complete. This course teaches engineers to master workflow orchestration patterns, abstract repeated configuration into reusable parameters and commands, and leverage the CircleCI Orbs ecosystem to standardize pipelines across the organization.* |
| Author Notes Additional resource notes | *GitHub repository: globomantics-advanced-circleci (extends existing Globomantics scenarios from Course 1)*  *All demos use CircleCI Free Plan (30,000 credits/month) — no paid tier features required*  *VS Code with CircleCI extension for config validation and development*  *GenAI integration: Use GitHub Copilot and CircleCI MCP server for config generation and troubleshooting*  *Comparison to GitHub Actions included (Orbs vs. Actions)*  *Azure deployment examples in Module 3 capstone* |
| Short Description Clear, engaging summary (250 Character limit) | *Complex pipelines require sophisticated orchestration. This course will teach you to design multi-stage workflows, implement configuration reuse with parameters, and leverage CircleCI Orbs for scalable, maintainable CI/CD.* |
| Long Description Summary of what the learner will be able to do or explain by the end of this course | *As CI/CD pipelines grow in complexity, engineers struggle with duplicated configuration, unreliable job sequencing, and difficulty maintaining consistency across repositories. In this course, CircleCI Advanced Configuration, you'll gain the ability to design production-grade pipelines that scale with your organization.*  *First, you'll explore multi-stage workflow orchestration using job dependencies, fan-out/fan-in patterns, and branch/tag filters. Next, you'll discover how to implement configuration reuse strategies using pipeline parameters, command definitions, and executor abstractions to eliminate YAML duplication.*  *Finally, you'll learn how to integrate certified Orbs from the CircleCI Registry to rapidly deploy common functions like Slack notifications, AWS deployments, and Azure integrations—while understanding the path to creating custom Orbs for your organization.*  *When you're finished with this course, you'll have the skills and knowledge of advanced CircleCI configuration needed to architect maintainable, scalable CI/CD pipelines for enterprise development teams.* |

| Learning Objectives  This section is completed by Curriculum | |
| --- | --- |
| Type | **Objectives** |
| Terminal | **1. Design and implement multi-stage workflows utilizing complex job dependencies and execution patterns.** |
| Enabling | * Define a sequential workflow using the requires keyword to enforce dependency order. * Configure parallel jobs using fan-out workflows to execute independent tasks simultaneously. * Utilize filters (branches, tags) to control which commits trigger specific workflow executions. |
| Terminal | **2. Implement configuration reuse strategies using parameters to abstract variable data in jobs and workflows.** |
| Enabling | * Create and reference parameters within job definitions to generalize functions. * Pass configuration parameters between jobs in a workflow using mapping. * Identify scenarios where custom parameters are superior to using environment variables for configuration. |
| Terminal | **3. Integrate and utilize certified Orbs to rapidly deploy common functions and third-party integrations.** |
| Enabling | Locate and install partner and certified orbs from the CircleCI Registry.   * Invoke pre-built commands and jobs from a community Orb (e.g., Slack Notifications ). * Analyze existing pipeline configuration to identify repetitive code suitable for extraction into a reusable component, upholding the config reuse best practice. * Review the configuration reference documentation to understand custom orb development requirements. |

| Course Organization  This section is completed by the Author | | |
| --- | --- | --- |
| 1 | **Terminal Objective 1: Design and implement multi-stage workflows utilizing complex job dependencies and execution patterns.**  *Enabling Objectives:*  *• Define sequential workflows using requires keyword*  *• Configure parallel jobs using fan-out workflows*  *• Utilize branch and tag filters for conditional execution*  **Module 1 — Workflow Orchestration Mastery**  **Clip 1: Beyond Sequential — Understanding Workflow Patterns (5 min)**  Lecture (PPT): Introduce the workflow orchestration problem at Globomantics — their monolithic pipeline runs jobs sequentially, wasting build minutes. Define three core patterns: sequential (build→test→deploy), parallel (unit tests + integration tests simultaneously), and fan-out/fan-in (multiple parallel jobs converging to a single deployment). Show animated workflow graphs demonstrating each pattern. Emphasize the requires keyword as the foundation of dependency management. Compare to GitHub Actions matrix builds.  **Clip 2: Building Sequential Dependencies with requires (5 min)**  Demo (Screencast): Open VS Code with CircleCI extension. Build a three-stage workflow: build → test → deploy. Show config.yml structure with requires: [build] on test job, requires: [test] on deploy job. Push to GitHub, watch workflow graph render in CircleCI dashboard showing dependency arrows. Demonstrate a failing build job and show how downstream jobs are automatically skipped. Use GenAI (Copilot) to suggest additional job configurations.  **Clip 3: Fan-Out Parallelism for Maximum Speed (5 min)**  Demo (Screencast): Refactor the Globomantics pipeline to run unit-tests, integration-tests, and security-scan in parallel, all requiring the build job. Show the dramatic time savings in the CircleCI UI — three 5-minute jobs completing in 5 minutes instead of 15. Add a deploy job that requires ALL three parallel jobs (fan-in pattern). Visualize the completed DAG in the workflow graph.  **Clip 4: Conditional Execution with Branch and Tag Filters (5 min)**  Lecture + Demo: Explain the filters key — control WHICH commits trigger WHICH jobs. Build production scenarios: deploy only runs on main branch, integration-tests only on pull requests, release-build only on tags matching v\*. Show config.yml filter syntax with branches: only: [main] and tags: only: /^v[0-9]+\.[0-9]+\.[0-9]+$/. Demo pushing to a feature branch — deploy job doesn't run. Push a v1.0.0 tag — release-build triggers. Show CircleCI's "Skipped" status for filtered jobs.  **Clip 5: Advanced Patterns — Matrix and Scheduled Workflows (5 min)**  Lecture + Demo: Introduce matrix-style testing using workflow parameters (full coverage in Module 2). Show scheduled workflows using triggers: for nightly builds and weekly dependency updates. Demonstrate the CircleCI UI scheduled trigger configuration. Briefly cover approval jobs (type: approval) for manual gates in deployment workflows — Globomantics uses these for production releases requiring manager sign-off.  **Clip 6: Module 1 Summary and Practice Challenge (5 min)**  Lecture: Recap the three workflow patterns (sequential, parallel, fan-out/fan-in) and filter types (branch, tag). Present the Globomantics challenge: design a workflow that builds once, tests in parallel across unit/integration/e2e, and deploys to staging on develop branch but production only on main with manual approval. Show the solution config.yml. Transition to Module 2 — now that workflows are orchestrated, let's make the configuration reusable. | **30 Mins**  **(10-40 min)** |
| 2 | **Terminal Objective 2: Implement configuration reuse strategies using parameters to abstract variable data in jobs and workflows.**  *Enabling Objectives:*  *• Create and reference parameters within job definitions to generalize functions*  *• Pass configuration parameters between jobs using mapping*  *• Identify when parameters beat environment variables*  **Module 2 — Configuration Reuse with Parameters**  **Clip 1: The DRY Principle in CI/CD Configuration (5 min)**  Lecture (PPT): Show Globomantics' config sprawl — three nearly identical jobs for deploying to dev, staging, and production. Introduce the DRY (Don't Repeat Yourself) principle applied to CI/CD. Define the configuration reuse hierarchy: Parameters (job/workflow level) → Commands (reusable step sequences) → Executors (environment abstractions) → Orbs (packaged components). Explain that parameters are the foundation — master these, and the rest follows.  **Clip 2: Pipeline Parameters for Workflow Control (5 min)**  Demo (Screencast): Introduce pipeline-level parameters using the parameters: key at config root. Create a boolean skip-tests parameter and a string deploy-environment parameter with enum constraint. Show how to trigger pipelines with custom parameter values via UI and API (curl example). Demonstrate conditional workflow execution using when: << pipeline.parameters.skip-tests >>. Use VS Code CircleCI extension for real-time validation.  **Clip 3: Job Parameters for Reusable Job Definitions (5 min)**  Demo (Screencast): Refactor three deploy jobs into one parameterized deploy job. Add parameters: block to job definition with environment (string), replicas (integer), and notify-slack (boolean). Use << parameters.environment >> syntax in run commands. Show workflow invoking the same job three times with different parameter values. Demonstrate the before (60 lines) vs. after (25 lines) config reduction.  **Clip 4: Parameters vs. Environment Variables — When to Use Which (5 min)**  Lecture + Demo: Critical distinction — parameters are resolved at CONFIG TIME (before job runs), environment variables at RUNTIME (during job execution). Parameters control WHAT runs (job selection, step conditions). Environment variables control HOW code runs (credentials, feature flags). Show a failure scenario: using environment variable in a when: condition (fails because it's config-time evaluation). Decision framework: If it affects pipeline structure → parameter. If it affects script behavior → environment variable.  **Clip 5: Commands — Reusable Step Sequences (5 min)**  Demo (Screencast): Extract repeated step sequences into commands: blocks. Create a setup-node command that combines checkout, restore\_cache, npm install, and save\_cache. Create a deploy-azure command with parameters for resource-group and app-name. Show jobs invoking these commands with - setup-node and - deploy-azure: { resource-group: globomantics-prod }. Emphasize commands as "functions" you can call from multiple jobs.  **Clip 6: Module 2 Summary and Practice Challenge (5 min)**  Lecture: Recap the reuse hierarchy — pipeline parameters (workflow control), job parameters (job generalization), commands (step abstraction). Present Globomantics challenge: They have a matrix testing scenario — same test suite must run against Node 18, 20, and 22. Design using a parameterized test job called three times with different node-version parameters. Show solution. Transition to Module 3 — commands are powerful, but Orbs take reuse to the ecosystem level. | **30 Mins**  **(10-40 min)** |
| 3 | **Terminal Objective 3: Integrate and utilize certified Orbs to rapidly deploy common functions and third-party integrations.**  *Enabling Objectives:*  *• Locate and install partner and certified orbs from the CircleCI Registry*  *• Invoke pre-built commands and jobs from community Orbs*  *• Analyze config for repetitive code suitable for orb extraction*  *• Review custom orb development requirements*  **Module 3 — Mastering Orbs and Reusable Components**  **Clip 1: The CircleCI Orbs Ecosystem (5 min)**  Lecture (PPT): Define Orbs as shareable, versioned packages of CircleCI configuration containing commands, jobs, and executors. Tour the CircleCI Orb Registry — show Certified (CircleCI-maintained), Partner (vendor-verified), and Community categories. Highlight key orbs: circleci/node, circleci/slack, circleci/aws-cli, circleci/azure-cli. Explain semantic versioning (major.minor.patch) and version pinning strategies. Compare Orbs to GitHub Actions: Orbs are declarative YAML packages; Actions are code/containers. Both solve reusability but with different philosophies.  **Clip 2: Installing and Using Your First Orb (5 min)**  Demo (Screencast): Add the circleci/node orb to Globomantics config. Show the orbs: declaration with version pinning (node: circleci/node@5.2.0). Replace manual npm install steps with node/install-packages command. Use the orb's executor with executor: node/default. Show the VS Code extension auto-completing orb parameters. Demonstrate the orb's built-in caching — point out the expanded steps in CircleCI UI showing restore\_cache and save\_cache happening automatically.  **Clip 3: Slack Notifications Orb — Real-World Integration (5 min)**  Demo (Screencast): Add circleci/slack orb. Configure SLACK\_WEBHOOK environment variable in CircleCI Contexts. Add slack/notify step to deployment job with custom message template. Show on\_success and on\_failure event triggers. Push a successful build — show Slack message arriving in channel. Push a failing build — show failure notification. This is production-ready monitoring in 10 lines of config vs. 50+ lines of custom webhook code.  **Clip 4: Cloud Deployment Orbs — Azure Integration (5 min)**  Demo (Screencast): Add circleci/azure-cli orb for Globomantics' Azure deployment. Configure OIDC authentication using Azure Federated Credentials (passwordless, secure). Use azure-cli/install and azure-cli/login-with-oidc commands. Deploy to Azure App Service with az webapp deploy. Show the complete secure deployment workflow: build → test → deploy-azure using orb commands. Compare to manual az cli scripting — orb abstracts authentication complexity.  **Clip 5: Analyzing Config for Orb Extraction Opportunities (5 min)**  Lecture + Demo: Show Globomantics' multi-repo problem — same custom deployment logic duplicated across 5 repositories. Walk through the refactoring thought process: identify repeated commands → extract to local commands → consider private orb. Tour CircleCI's custom orb development documentation. Show the orb.yml structure: commands, jobs, executors, examples. Explain orb publishing workflow: orb init, orb validate, orb publish. Note: Private orbs are FREE on all plans — this is a key differentiator for enterprise adoption.  **Clip 6: Capstone — Complete Globomantics Pipeline (5 min)**  Demo (Screencast): Synthesize all three modules into the final Globomantics pipeline. Show the complete config.yml: fan-out workflow (build → parallel tests → deploy), parameterized jobs (deploy to dev/staging/prod), orb integrations (node, slack, azure-cli). Walk through the workflow graph visualization. Show credit consumption comparison: optimized pipeline vs. original sequential approach — 40% reduction in build time, 25% credit savings. Summarize the course: workflow orchestration, configuration reuse, and orb-powered integrations transform CI/CD from configuration burden to competitive advantage. | **30 Mins**  **(10-40 min)** |
